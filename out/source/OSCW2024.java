/* autogenerated by Processing revision 1293 on 2024-12-21 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Collections;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class OSCW2024 extends PApplet {

public enum STATE { NEW, READY, BLOCKED, RUNNING, EXITING }
public enum SDLRTYPE { PREEMPTIVE, NONPREEMPTIVE }
public enum MMANAGERTYPE { VARIABLE, FIXED }

Hardware myPC;
OperatingSystem myOS;
Simulator sim;
static int pidCounter;

public void setup() {
  /* size commented out by preprocessor */;
  pidCounter = 0;
  //setup the hardware. Arguments: Number of RAM Chips, Size of each chip (in chars)
  myPC = new Hardware(4, 60);
  //setup the OS. arguments: Number of user partitions in RAM when we boot
  myOS = new OperatingSystem(1);
  //Create and add to the kernel the kernel processes.
  //NOTE: the names are important. They are used to access the kernel processes from other processes
  //The order that are added determine the kernel image
  //Arguments: Name, Code, IRQ
  myOS.addToKernel(new IdleKernel("idle", "I", 5));
  //Arguments: Name, Code, IRQ, Memory manager Algorithm
  myOS.addToKernel(new MemoryManagerKernel("memoryManager", "*M", 3, new FirstFitMM()));
  //Arguments: Name, Code, IRQ
  myOS.addToKernel(new CreateProcessKernel("createProcess", "C", 2));
  //Arguments: Name, Code, IRQ
  myOS.addToKernel(new AdmitProcessKernel("admitProcess", "A", 1));
  //Arguments: Name, Code, IRQ
  myOS.addToKernel(new SchedulerKernel("scheduler", "S", 4, new FCFScheduler()));
  //Arguments: Name, Code, IRQ, scheduler Algorithm
  myOS.addToKernel(new ExitProcessKernel("exitProcess", "X", 6));
  //Arguments: Name, Code, IRQ
  myOS.addToKernel(new CoalesceKernel("coalesce", "N", 7));
  //Arguments: Name, Code, IRQ
  myOS.addToKernel(new CompactKernel("compact", "P", 8));
  sim = new Simulator();
  sim.setupSimulation();
}

public void draw() {
  sim.update();
}

public void keyPressed() {
  
  if (key == CODED) {
    if (keyCode == LEFT) {
      sim.decreaseSpeed();
    } else if (keyCode == RIGHT) {
      sim.increaseSpeed();
    }
  } else{
    if (key == '1') {
      myPC.keyBoardEvent(1);  
    } else if (key == '2') {
      myPC.keyBoardEvent(2);  
    } else if (key == '3') {
      myPC.keyBoardEvent(3);  
    } else if (key == 'p' || key == 'P') {
      sim.isRunning = !sim.isRunning;  
    } else if (key == 'q' || key == 'Q') {
      sim.endSimulation();  
    } else if (key == 's' || key == 'S') {
      sim.step();
      sim.render();
    }
  }
}
public abstract class ShortTermScheduler{
  SDLRTYPE type;
  
  public abstract UserProcess selectUserProcess();
}
////////////////////////////////////////////////////////////////////
public abstract class MemoryManagerAlgorithm{
  MMANAGERTYPE type;
  
  public abstract Partition selectPartition();
}
////////////////////////////////////////////////////////////////////
public class DefaultScheduler extends ShortTermScheduler{
  
  DefaultScheduler() {
    super();
    type = SDLRTYPE.PREEMPTIVE;
  }
  
  public UserProcess selectUserProcess() {
    UserProcess result = null;
    if (myOS.suspended != null) {
      sim.addToLog("  >Scheduler: suspended process found (" + myOS.suspended.pid + ") in the ready queue");
      result = myOS.suspended;
      myOS.suspended = null;
    } else if (!myOS.readyQueue.isEmpty()) {
      result = myOS.readyQueue.get(0); 
    }
    return result;
  }
  
}

//////////////////////////////////////////////////////////////
public class DefaultMM extends MemoryManagerAlgorithm{
  
  DefaultMM() {
    super();
    type = MMANAGERTYPE.FIXED;
  }
  
  public Partition selectPartition() {
    Partition result = null;
    for (int i = 1; i < myOS.partitionTable.size(); i++) {
      if (myOS.partitionTable.get(i).isFree && myOS.partitionTable.get(i).size >= myOS.newProcessImage.length()) {
        result = myOS.partitionTable.get(i);
        result.isFree = false;
        break;
      }
    }
    if (result != null) {
      sim.addToLog("  >Memory Manager: Partition with BA: " + result.baseAddress + " was found. Starting Process Creator");
      myOS.raiseIRQ("createProcess");
    } else {
      sim.addToLog("  >Memory Manager: No partition was found. Starting Process Scheduler");
      sim.requestFails++;
      myOS.raiseIRQ("scheduler");
    }
    return result;
  }
  
}
public class Hardware {
  /*Instruction set
  * = any instruction
  $ = an exit instruction
  d = data like static variables / constants
  A program will look like this:
  *******$dddd
  */
  
  //CPU
  char IR; //Intruction register
  int counter; //Program counter
  int MAR; //Memory Address Register
  int BA; //Base address
  
  //RAM
  char[][] RAM;
  int RAMBanks; // between 1 to 4 banks
  final int maxRAMSizeInBank = 80;
  final int minRAMSizeInBank = 40;
  final int maxRAMBanks = 4;
  int RAMSizeInBank;   // between 40 to 360 chars
  int RAMSize;
  
  //HDD
  //filename --> code
  HashMap<String, String>HDD;
  
  //clock
  int clock;
  
  //Keyboard Buffer
  ArrayList<Integer> keyboardBuffer;
  
  //Interrupts
  boolean interruptsEnabled;
  boolean[] IRQ;
  char[] IRQname;
  
  Hardware(int nb, int bs) {
    RAMBanks = constrain(nb, 1, maxRAMBanks);
    RAMSizeInBank = constrain(bs, minRAMSizeInBank, maxRAMSizeInBank);
    RAM = new char[RAMBanks][RAMSizeInBank];
    HDD = new HashMap<String, String>();
    keyboardBuffer = new ArrayList<Integer>();
    IRQ = new boolean[16];  
    IRQname = new char[IRQ.length];
    //0 for keyboard event
    //>0 for OS 
    
  }
  
  //PUBLIC  METHODS
  /////////////////////////////
  public void powerOn() {
    checkRAM();
    mountHDD();
    //start my OS
    myOS.boot();
    interruptsEnabled = true;
    for (int i = 0; i < IRQ.length; i++) {
      IRQ[i] = false;
    }
  }
  
  public void keyBoardEvent(int k) {
    IRQ[0] = true;  //<>//
    keyboardBuffer.add(k);  //<>//
    sim.addToLog(">User: Pressed button " + k);
  }
  
  public void ticToc() {
    //increment the clock
    clock++;
    //either do a fetch or an execute
    if (clock % 2 == 1) {
      handleInterrupts();
      fetch();
    } else {
      execute();
    }
  }
  
  //PRIVATE METHODS
  ///////////////////////////
  
  private void handleInterrupts() {
    if (interruptsEnabled) {
      //Lower the number higher the priority
      for (int i = 1; i < IRQ.length; i++) { //<>//
        if (IRQ[i]) {
          myOS.handleInterrupt(i);
          IRQ[i] = false;
          break;
        }
      }
      if (IRQ[0]) {
        int k = keyboardBuffer.remove(0); 
        myOS.request = "program" + k + ".exe";
        if (keyboardBuffer.isEmpty()) {
          IRQ[0] = false;
        }
        sim.requestTotal++;
        sim.addToLog(">myPC: Keyboard interrupt handled. Request for " + myOS.request + ". Staring Memory Manager");
        myOS.raiseIRQ("memoryManager");
      }
    }
  }
  
  private void checkRAM() {
    //calculate how much RAM is available
    RAMSize = RAMBanks * RAMSizeInBank;
    //initialise the RAM by writting the ' ' in every position
    for (int i = 0; i < RAMBanks; i++) {
      for (int j = 0; j < RAMSizeInBank; j++) {
        RAM[i][j] = ' ';
      }
    }
  }
  
  private void mountHDD() {
    HDD.put("program1.exe", "****$ddd");
    HDD.put("program2.exe", "*********$ddddd");
    HDD.put("program3.exe", "****************$dddddddd");
  }
  
  private void fetch() {
    MAR = BA + counter;
    IR = RAM[MAR / RAMSizeInBank][MAR % RAMSizeInBank];
    sim.addToLog(">myPC: At time " + clock + " fetched a " + IR);
  }
  
  private void execute() {
    sim.addToLog(">myPC: At time " + clock + " executed a " + IR);
    myOS.call(IR);
    if (IR ==  '*') {
      counter++;
    }
  }
}
public abstract class KernelProcess extends PCB{
  String code;
  char completeInstruction;
  int IRQnum;
  
  KernelProcess(String name, String c, int IRQ) {
    super(0, name);  
    IRQnum = IRQ;
    code = c;
    completeInstruction = code.charAt(code.length() - 1);
    state = STATE.READY;
  }
  
  public void start() {
    myOS.kernelMode = true;
    myPC.interruptsEnabled = false;
    this.state = STATE.RUNNING;
    myPC.counter = 0;
    myPC.BA = this.baseAddress;  
    myOS.active = this;
  }
  
  public void setIRQ(boolean value) {
    myPC.IRQ[IRQnum] = value;  
  }
  
  public String compileTo(String kernelImage) {
    this.baseAddress = kernelImage.length();
    return kernelImage + code;
  }
  
}

///////////////////////////////////////////////////////////
public class IdleKernel extends KernelProcess{
  
  IdleKernel(String name, String code, int IRQ) {
    super(name, code, IRQ);
  }
  
  //Overwrite default start to enable interrupts
  public void start() {
    super.start();
    myPC.interruptsEnabled = true; 
  }
  
  public void finish() {
    myPC.counter = 0;
  }
  
}

///////////////////////////////////////////////////////////
public class MemoryManagerKernel extends KernelProcess{
  
  MemoryManagerAlgorithm algorithm;
  
  MemoryManagerKernel(String name, String code, int IRQ, MemoryManagerAlgorithm mm) {
    super(name, code, IRQ);
    algorithm = mm;
  }
  
  //Overwrite default start to suspent user processes
  //If the scheduler is non preemtive, the active process
  //can never be a user process
  public void start() {
    if (myOS.active instanceof UserProcess) {
      sim.addToLog(" >MyOS: suspending process " + myOS.active.pid);
      myOS.suspended = (UserProcess) myOS.active;
      myOS.suspended.pause();
      myOS.readyQueue.add(myOS.suspended);
      sim.addToLog(" >MyOS: adding suspended process (" + myOS.active.pid + ") to ready queue");
    } else {
      myOS.kernel.get("idle").state = STATE.READY;
    }
    super.start();
  }
  
  public void finish() {
    myOS.newProcessImage = myPC.HDD.get(myOS.request) + myOS.processTail;
    myOS.partitionFound = algorithm.selectPartition();
    this.state = STATE.READY;
    myPC.interruptsEnabled = true;
  }
  
}

///////////////////////////////////////////////////////////////
public class CreateProcessKernel extends KernelProcess{
  
  CreateProcessKernel(String name, String code, int IRQ) {
    super(name, code, IRQ);
  }
  
  public void finish() {
    myOS.newProcess = new UserProcess(myOS.partitionFound.baseAddress, myOS.request);
    myOS.processTable.add(myOS.newProcess);
    myOS.writeToPartition(myOS.partitionFound, myOS.newProcessImage);
    sim.addToLog("  >Process Creator: process with PID " + myOS.newProcess.pid + " created at partition " + myOS.partitionTable.indexOf(myOS.partitionFound) + " (BA " + myOS.partitionFound.baseAddress + "). Starting process admitter");
    myOS.raiseIRQ("admitProcess");
    this.state = STATE.READY;
    myPC.interruptsEnabled = true;
  }
}

///////////////////////////////////////////////////////////////
public class AdmitProcessKernel extends KernelProcess{
  
  AdmitProcessKernel(String name, String code, int IRQ) {
    super(name, code, IRQ); 
  }
  
  public void finish() {
    this.state = STATE.READY;
    myOS.newProcess.state = STATE.READY;
    myOS.newProcess.loadTime = myPC.clock;
    myOS.readyQueue.add(myOS.newProcess);
    sim.addToLog("  >Process Admitter: Admitted process " + myOS.newProcess.pid + " to the readyQueue. Starting Scheduler");
    myOS.raiseIRQ("scheduler");
    myPC.interruptsEnabled = true;
  }
  
}

///////////////////////////////////////////////////////////////
public class SchedulerKernel extends KernelProcess{
  private ShortTermScheduler scheduler;
  
  SchedulerKernel(String name, String code, int IRQ, ShortTermScheduler sc) {
    super(name, code, IRQ);
    scheduler = sc;
  }
  
  public boolean isPreEmptive() {
    boolean result = scheduler.type == SDLRTYPE.PREEMPTIVE;
    return result;
  }
  
  public void finish() {
    myOS.active = scheduler.selectUserProcess();
    if (myOS.active == null) {
      sim.addToLog("  >Scheduler: ready queue is empty. Switching to IDLE");
      myOS.raiseIRQ("idle");
      myPC.interruptsEnabled = true;
    } else{
      sim.addToLog("  >Scheduler: selected from the ready queue process " + myOS.active.pid);
      myOS.readyQueue.remove(myOS.active);
      myPC.interruptsEnabled = isPreEmptive();
    }
    if (myOS.active!= null) myOS.active.start();
    myOS.kernelMode = false;
    this.state = STATE.READY;
  }
}

///////////////////////////////////////////////////////////////
public class ExitProcessKernel extends KernelProcess{
  
  ExitProcessKernel(String name, String code, int IRQ) {
    super(name, code, IRQ);
  }
  
  public void finish() {
    myOS.emptyPartition(myOS.deleteProcess.baseAddress);
    myOS.processTable.remove(myOS.deleteProcess);
    sim.addToLog("  >Exit: finished exiting process " + myOS.deleteProcess.pid + ". Starting coalesce");
    // Removed to get deleteProcess in coalesce and will be set to null there
    // myOS.deleteProcess = null;
    
    // Moved to coalesce 
    // myOS.startKernelProcess("scheduler");
    
    // Call the coalesce
    myOS.startKernelProcess("coalesce");
    this.state = STATE.READY;
  }
  
}


// * Schedulers
// Shortest Job First Scheduler
// Pick the process with the shortest burst time
public class ShortestJobFirstScheduler extends ShortTermScheduler{
    
    ShortestJobFirstScheduler() {
        super();
        type = SDLRTYPE.NONPREEMPTIVE;
    }
    
    public UserProcess selectUserProcess() {
        UserProcess result = null;
        if (!myOS.readyQueue.isEmpty()) {
            result = myOS.readyQueue.get(0);
            for (int i = 1; i < myOS.readyQueue.size(); i++) {
                if (result.codeSize > myOS.readyQueue.get(i).codeSize) {
                    result = myOS.readyQueue.get(i);
                }
            }
        }
        return result;
    }
    
}

///////////////////////////////////////////////////////////////
// Priority Queue Scheduler
// Pick the first process with the highest priority
public class PriorityQueueScheduler extends ShortTermScheduler{
    
    PriorityQueueScheduler() {
        super();
        type = SDLRTYPE.PREEMPTIVE;
    }
    
    public UserProcess selectUserProcess() {
        UserProcess result = null;
        if (!myOS.readyQueue.isEmpty()) {
            result = myOS.readyQueue.get(0);
            for (int i = 1; i < myOS.readyQueue.size(); i++) {
                if (result.priority > myOS.readyQueue.get(i).priority) {
                    result = myOS.readyQueue.get(i);
                } else if (result.priority == myOS.readyQueue.get(i).priority) {
                    if (result.programCounter > myOS.readyQueue.get(i).programCounter) {
                        result = myOS.readyQueue.get(i);
                    }
                }
            } 
        }
        return result;
    }
    
}

///////////////////////////////////////////////////////////////
// First Come First Serve Scheduler
// Pick the first process in the ready queue
public class FCFScheduler extends ShortTermScheduler{
    
    FCFScheduler() {
        super();
        //NONPREMPTIVE HAS ERRORIN SIMULATOR
        type = SDLRTYPE.PREEMPTIVE;
    }
    
    public UserProcess selectUserProcess() {
        UserProcess result = null;
        if (myOS.suspended != null) {
            sim.addToLog("  >Scheduler: suspended process found (" + myOS.suspended.pid + ") in the ready queue");
            result = myOS.suspended;
            myOS.suspended = null;
        } else if (!myOS.readyQueue.isEmpty()) {
            result = myOS.readyQueue.get(0); 
        }
        return result;
    }
}

///////////////////////////////////////////////////////////////
// Shortest Remaining Time Next Scheduler
// Pick the process with the shortest remaining burst time
public class SRTNScheduler extends ShortTermScheduler{
    
    SRTNScheduler() {
        super();
        type = SDLRTYPE.PREEMPTIVE;
    }
    
    public UserProcess selectUserProcess() {
        UserProcess result = null;
        if (myOS.suspended != null) {
            sim.addToLog("  >Scheduler: suspended process found (" + myOS.suspended.pid + ") in the ready queue");
            result = myOS.suspended;
            myOS.suspended = null;
        } else if (!myOS.readyQueue.isEmpty()) {
            result = myOS.readyQueue.get(0);
            for (int i = 1; i < myOS.readyQueue.size(); i++) {
                if ((result.codeSize - result.programCounter) > (myOS.readyQueue.get(i).codeSize - myOS.readyQueue.get(i).programCounter)) {
                    result = myOS.readyQueue.get(i);
                }
            }
        }
        return result;
    }
}

///////////////////////////////////////////////////////////////
// *Memory Managers
// First Fit Memory Manager
// Pick the first partition that fits the process size
public class FirstFitMM extends MemoryManagerAlgorithm{
  
  FirstFitMM() {
    super();
    type = MMANAGERTYPE.VARIABLE;
  }
  
  public Partition selectPartition() {
    Partition result = null;
    for (int i = 1; i < myOS.partitionTable.size(); i++) {
      if (myOS.partitionTable.get(i).isFree && myOS.partitionTable.get(i).size >= myOS.newProcessImage.length()) {
        result = myOS.partitionTable.get(i);
        result.isFree = false;
        break;
      }
    }
    if (result != null) {
      if (result.size > myOS.newProcessImage.length()) splitPartition(result, myOS.newProcessImage.length());
      sim.addToLog("  >Memory Manager : Partition with BA : " + result.baseAddress + " was found.Starting Process Creator");
      myOS.raiseIRQ("createProcess");
    } else{
      sim.addToLog("  >Memory Manager: No partition was found. Starting Compact Kernel");
      sim.requestFails++;
      // Moved to compact kernel
      // myOS.raiseIRQ("scheduler");
      myOS.raiseIRQ("compact");
    }
    return result;
  }
  
}

///////////////////////////////////////////////////////////////
// Best Fit Memory Manager
// Pick the biggest partition that fits the process size
public class WorstFitMM extends MemoryManagerAlgorithm{
  
  WorstFitMM() {
    super();
    type = MMANAGERTYPE.VARIABLE;
  }
  
  public Partition selectPartition() {
    Partition result = null;
    int maxSize = 0;
    for (int i = 0; i < myOS.partitionTable.size(); i++) {
      if (myOS.partitionTable.get(i).isFree && maxSize < myOS.partitionTable.get(i).size && myOS.partitionTable.get(i).size >= myOS.newProcessImage.length()) {
        result = myOS.partitionTable.get(i);
        maxSize = result.size;
      }
    }
    if (result != null) {
      if (result.size > myOS.newProcessImage.length()) splitPartition(result, myOS.newProcessImage.length());
      result.isFree = false;
      sim.addToLog("  >Memory Manager: Partition with BA: " + result.baseAddress + " was found. Starting Process Creator");
      myOS.raiseIRQ("createProcess");
    } else{
      sim.addToLog("  >Memory Manager: No partition was found. Starting Compact Kernel");
      sim.requestFails++;
      // Moved to compact kernel
      // myOS.raiseIRQ("scheduler");
      myOS.raiseIRQ("compact");
    }
    return result;
  }
}

// Split the selected partition into two partitions with the process size and the remaining size
private void splitPartition(Partition partition, int processSize) {
    int partitionBSize = partition.size - processSize;
    int partitionABA = partition.baseAddress;
    int partitionBBA = partitionABA + processSize;
    int partitionId = myOS.partitionTable.indexOf(partition);
    Partition partitionA = new Partition(partitionABA, processSize);
    partitionA.isFree = false;
    Partition partitionB = new Partition(partitionBBA, partitionBSize);
    myOS.partitionTable.remove(partition);
    myOS.partitionTable.add(partitionId, partitionA);
    myOS.partitionTable.add(partitionId + 1, partitionB);
}

///////////////////////////////////////////////////////////////
// * Kernel Processes
// Coalesce Kernel
// Check if there are adjacentfree partitions to merge with the cleared partition
public class CoalesceKernel extends KernelProcess{
    CoalesceKernel(String name, String code, int IRQ) {
        super(name, code, IRQ);
    }
    
    public void finish() {
        Partition deletePartition = myOS.searchPartitionTable(myOS.deleteProcess.baseAddress);
        int deletePartitionIndex = myOS.partitionTable.indexOf(deletePartition);
        
        if (isNotFirst(deletePartitionIndex)) {
            if (isNotLast(deletePartitionIndex)) {
                if (isPreviousAndNextFree(deletePartitionIndex)) {
                    coalescePreviousAndNext(deletePartitionIndex);
                    sim.addToLog("  >Coalesce: Merged previous, current, and next partitions.");
                } else if (isPreviousFree(deletePartitionIndex)) {
                    coalescePrevious(deletePartitionIndex);
                    sim.addToLog("  >Coalesce : Merged previous partition with current.");
                } else if (isNextFree(deletePartitionIndex)) {
                    coalesceNext(deletePartitionIndex);
                    sim.addToLog("  >Coalesce: Merged next partition with current.");
                } else {
                    sim.addToLog("  >Coalesce : No adjacent free partitions to merge.");
                }
            } else {
                if (isPreviousFree(deletePartitionIndex)) {
                    coalescePrevious(deletePartitionIndex);
                    sim.addToLog("  >Coalesce: Merged previous partition with current.");
                } else {
                    sim.addToLog("  >Coalesce : No adjacentfree partitions to merge.");
                }
            }
        } else if (isNotLast(deletePartitionIndex)) {
            if (isNextFree(deletePartitionIndex)) {
                coalesceNext(deletePartitionIndex);
                sim.addToLog("  >Coalesce : Merged next partition with current.");
            } else {
                sim.addToLog("  >Coalesce : No adjacent free partitions to merge.");
            }
        } else {
            sim.addToLog("  >Coalesce : No adjacent free partitions to merge.");
        }
        
        sim.addToLog("  >Coalesce: Finished coalescing partition " + deletePartition.baseAddress + ".Starting Process Scheduler");
        myOS.startKernelProcess("scheduler");
        this.state = STATE.READY;
    } 
    //Position check
    //Check if partition is not first
    private boolean isNotFirst(int currentPartitionIndex) {
        return currentPartitionIndex > 0;
    }
    //Check if partition is not last
    private boolean isNotLast(int currentPartitionIndex) {
        return currentPartitionIndex < myOS.partitionTable.size() - 1;
    }
    
    //Free check
    //Check if previous and next partitions are free
    private boolean isPreviousAndNextFree(int currentPartitionIndex) {
        return isPreviousFree(currentPartitionIndex) && isNextFree(currentPartitionIndex);
    }
    //Check if previous partition is free
    private boolean isPreviousFree(int currentPartitionIndex) {
        Partition previousPartition = myOS.partitionTable.get(currentPartitionIndex - 1);
        return previousPartition.isFree;
    }
    //Check if next partition is free
    private boolean isNextFree(int currentPartitionIndex) {
        Partition nextPartition = myOS.partitionTable.get(currentPartitionIndex + 1);
        return nextPartition.isFree;
    } 
    
    //Coalesce
    //Merge previous, current, and next partitions
    private void coalescePreviousAndNext(int currentPartitionIndex) {
        //Merge partitions previous and next with current
        Partition currentPartition = myOS.partitionTable.get(currentPartitionIndex);
        Partition previousPartition = myOS.partitionTable.get(currentPartitionIndex - 1);
        Partition nextPartition = myOS.partitionTable.get(currentPartitionIndex + 1);
        previousPartition.size += currentPartition.size + nextPartition.size;
        myOS.partitionTable.remove(currentPartition);
        myOS.partitionTable.remove(nextPartition);
    }
    //Merge previous with current
    private void coalescePrevious(int currentPartitionIndex) {
        //Merge partitions previous with current
        Partition currentPartition = myOS.partitionTable.get(currentPartitionIndex);
        Partition previousPartition = myOS.partitionTable.get(currentPartitionIndex - 1);
        previousPartition.size += currentPartition.size;
        myOS.partitionTable.remove(currentPartition);
    }
    //Merge next with current
    private void coalesceNext(int currentPartitionIndex) {
        //Merge partitions next with current
        Partition currentPartition = myOS.partitionTable.get(currentPartitionIndex);
        Partition nextPartition = myOS.partitionTable.get(currentPartitionIndex + 1);
        currentPartition.size += nextPartition.size;
        myOS.partitionTable.remove(nextPartition);
    }
}

///////////////////////////////////////////////////////////////
// Compact Kernel
public class CompactKernel extends KernelProcess{
  CompactKernel(String name, String code, int IRQ) {
    super(name, code, IRQ);
  }
  
  public void finish() {
    ArrayList<Partition> partitionTable = myOS.partitionTable;

    // Compact partitions
    sort(partitionTable);
    mergePartitions(partitionTable);

    // Log the final partition tables once
    sim.addToLog(myOS.partitionTable.toString());
    myOS.startKernelProcess("scheduler");
  }


private void sort(ArrayList<Partition> partitionTable) {
    int i, j;
    boolean swapped;
    int n = partitionTable.size();
    for (i = 0; i < n - 1; i++) {
      swapped = false;
      for (j = 0; j < n - i - 1; j++) {
        if (isSwappable(partitionTable, j)) {
            // Swap
            Collections.swap(partitionTable, j, j + 1);
            swapped = true;
        }
      }
      // If no two elements were
      // swapped by inner loop, then break
      if (!swapped) break;
    }
  }
  
  /*
  private void sort(ArrayList<Partition> partitionTable) {
    int n = partitionTable.size();
    for (int i = 0; i < n - 1; i++) {
      // Assume the current position holds
      // the minimum element
      int min_idx = i;

      // Iterate through the unsorted portion
      // to find the actual minimum
      for (int j = i + 1; j < n; j++) {
        if (isSwappable(partitionTable, j)) {
            // Update min_idx if a smaller element
            // is found
            min_idx = j;
        }
      }
      // Move minimum element to its correct position
      Collections.swap(partitionTable, i, min_idx);        
    }
  }*/

  private void mergePartitions(ArrayList<Partition> partitionTable) {
    int i = 0;
    while (i < partitionTable.size() - 1) {
        Partition currentPartition = partitionTable.get(i);
        Partition nextPartition = partitionTable.get(i + 1);
        if (currentPartition.isFree && nextPartition.isFree) {
            // Merge current and next partitions
            currentPartition.size += nextPartition.size;
            partitionTable.remove(i + 1); // Remove the next partition
            partitionsMerged++;
        } else {
            i++; // Move to the next partition only if no merge happened
        }
    }
  }

  private boolean isSwappable(ArrayList<Partition> partitionTable, int index) {
    return partitionTable.get(index).isFree && !partitionTable.get(index + 1).isFree;
  }
}
public class OperatingSystem {
  public int partitions;
  
  //Shared OS data
  public ArrayList<Partition> partitionTable;
  public ArrayList<PCB> processTable;
  public ArrayList<UserProcess> readyQueue;
  public final String processTail = "hhhhhssss";
  public String request;
  public String newProcessImage;
  public Partition partitionFound;
  public UserProcess newProcess;
  public UserProcess deleteProcess;
  public PCB active;
  public UserProcess suspended;
  
  //Kernel Information
  public boolean kernelMode;
  public String kernelImage = "";
  public HashMap<String, KernelProcess> kernel;
  //public IdleKernel idle;
  //public MemoryManagerKernel memoryManager;
  //public CreateProcessKernel createProcess;
  //public AdmitProcessKernel admitProcess;
  //public SchedulerKernel scheduler;
  //public ExitProcessKernel exitProcess;
  
  OperatingSystem(int p) {
    partitions = p;
    partitionTable = new ArrayList<Partition>();
    processTable = new ArrayList<PCB>();
    readyQueue = new ArrayList<UserProcess>();
    kernel = new HashMap<String, KernelProcess>();
  }
  
  //PUBLIC METHODS
  ////////////////////////////
  //Lower the number higher the priority
  //1 for invoke process admitter
  //2 for invoke process creator  
  //3 for invoke memory manager
  //4 for invoke process scheduler 
  //5 for invoke idle
  //6 for invoke process eliminator 
  
  public void addToKernel(KernelProcess k) {
    kernel.put(k.reference, k);
    kernelImage = k.compileTo(kernelImage);  
  }
  
  public void boot() {
    sim.addToLog(" >myOS: Booting OS");
    int partitionBA = 0;
    partitionTable.add(new Partition(partitionBA, kernelImage.length()));
    partitionBA += kernelImage.length();
    int partitionSize = (myPC.RAMSize - kernelImage.length()) / partitions;
    for (int i = 0; i < partitions; i++) {
      partitionTable.add(new Partition(partitionBA, partitionSize));
      partitionBA += partitionSize;
    } 
    myPC.IRQname[0] = 'K';
    for (KernelProcess k : kernel.values()) {
      processTable.add(k);
      myPC.IRQname[k.IRQnum] = k.completeInstruction;;
    }
    loadOSImage();
  }
  
  public void handleInterrupt(int IRQnum) {
    for (KernelProcess k : kernel.values()) {
      if (IRQnum == k.IRQnum) {
        k.start();
        break;
      }
    }
  }
  
  public void call(char instruction) {
    if (instruction == '*') {
      if (kernelMode) {
        sim.contextSwitchTime += 2;
      } else{
        sim.utilisationTime += 2;
      }
    } else if (instruction == '$') {
      sim.utilisationTime += 2;
      sim.addToLog(" >myOS: Exiting the running process");
      myOS.deleteProcess = (UserProcess) myOS.active;
      myOS.deleteProcess.finish();
      sim.processStatistics.add(new ProcessStats(deleteProcess));
      kernel.get("exitProcess").setIRQ(true);
    } else if (instruction == kernel.get("idle").completeInstruction) {
      sim.idleTime += 2;
      sim.addToLog(" >myOS: System is idle. Waiting for user input");
      finishKernelProcess("idle");
    } else if (instruction == kernel.get("memoryManager").completeInstruction) {
      sim.contextSwitchTime += 2;
      sim.addToLog(" >myOS: Finished running memory manager");
      finishKernelProcess("memoryManager");
    } else if (instruction == kernel.get("createProcess").completeInstruction) {
      sim.contextSwitchTime += 2;
      sim.addToLog(" >myOS: Finished creating process");
      finishKernelProcess("createProcess");
    } else if (instruction == kernel.get("admitProcess").completeInstruction) {
      sim.contextSwitchTime += 2;
      sim.addToLog(" >myOS: Finished admitting process to the ready queue");
      finishKernelProcess("admitProcess");
    } else if (instruction == kernel.get("scheduler").completeInstruction) {
      sim.contextSwitchTime += 2;
      sim.addToLog(" >myOS: Finished scheduling");
      finishKernelProcess("scheduler");
    } else if (instruction == kernel.get("exitProcess").completeInstruction) {
      sim.contextSwitchTime += 2;
      sim.addToLog(" >myOS: Finished exiting program " + myOS.active.pid);
      finishKernelProcess("exitProcess");
    } else if (instruction == kernel.get("coalesce").completeInstruction) {
      sim.contextSwitchTime += 2;
      sim.addToLog(" >myOS: Coalesce partition " + myOS.deleteProcess.baseAddress);
      finishKernelProcess("coalesce");
    } else if (instruction == kernel.get("compact").completeInstruction) {
      sim.contextSwitchTime += 2;
      sim.addToLog(" >myOS: Compact partitions");
      finishKernelProcess("compact");
    } else{
      sim.addToLog(" >myOS: ERROR 101 Undefined instruction");
    }
  }
  
  public void startKernelProcess(String name) {
    kernel.get(name).start();
  }
  
  public void finishKernelProcess(String name) {
    kernel.get(name).finish();
  }
  
  public void raiseIRQ(String name) {
    kernel.get(name).setIRQ(true);
  }
  
  //PRIVATE METHODS
  ///////////////////////////
  
  private void loadOSImage() {
    writeToPartition(partitionTable.get(0), kernelImage);
    sim.addToLog("  >myOS: Kernel image written to OS partition. Starting IDLE");
    startKernelProcess("idle");
  }
  
  private void writeToPartition(Partition p, String processImage) {
    if (p.size >= processImage.length()) {
      for (int i = 0; i < processImage.length(); i++) {
        writeToRAM(p.baseAddress + i, processImage.charAt(i));
      }
      p.isFree = false;
    }
  } 
  
  private void writeToRAM(int address, char x) {
    int bank = address / myPC.RAMSizeInBank;
    int position = address % myPC.RAMSizeInBank;
    myPC.RAM[bank][position] = x;
  }
  
  private void emptyPartition(int ba) {
    Partition p = searchPartitionTable(ba);
    for (int i = 0; i < p.size; i++) {
      myOS.writeToRAM(p.baseAddress + i, ' ');
    }
    p.isFree = true;
  }
  
  private Partition searchPartitionTable(int ba) {
    Partition p = null;
    for (int i = 0; i < myOS.partitionTable.size(); i++) {
      if (myOS.partitionTable.get(i).baseAddress == ba) {
        p = myOS.partitionTable.get(i);
        break;
      }
    }
    return p;
  }
  
}
public abstract class PCB {
  
  int pid; //who am I?
  STATE state; //STATE
  int baseAddress; //where in RAM am I?
  int programCounter; //how far have I progressed
  String reference; //Which program it is for
  
  PCB(int ba, String ref) {
    pid = pidCounter++;
    state = STATE.NEW;
    baseAddress = ba;
    programCounter = 0;
    reference = ref;
  }
  
  public abstract void start();
  
  public abstract void finish();
  
  public String toString() {
    String result = sim.int2String(pid, 4) + " :" + sim.int2String(programCounter, 3) + " :";
    if (state == STATE.NEW)      result += "NEW    ";
    else if (state == STATE.READY) result += "READY  ";
    else if (state == STATE.RUNNING) result += "RUNNING";
    else if (state == STATE.BLOCKED) result += "BLOCKED";
    else                result += "EXITING";
    result += ": " + reference;
    return result;
  }
  
}
public class Partition {
  //base address
  int baseAddress;
  //size
  int size;
  //is it free?
  boolean isFree;
  
  Partition(int ba, int s) {
    baseAddress = ba;
    size = s;
    isFree = true;
  }
}
class ProcessStats {
  int pid;//int PID; //Who am I?
  int baseAddress; //Where am I?
  int loadTime; //When was I created?
  int startTime;
  String name; //What is the program?
  int responseTime; //how much time did it pass to run the first instruction?
  int turnarroundTime; //how much time did it pass to run the last instruction?
  
  ProcessStats(UserProcess process) {
    pid = process.pid;
    baseAddress = process.baseAddress;
    loadTime = process.loadTime;
    startTime = process.startTime;
    responseTime = startTime - loadTime;
    turnarroundTime = process.finishTime - loadTime;
    name = process.reference;
  }
  
  public String toString() {
    String result = ":";
    result += sim.int2String(pid, 10);
    result += sim.int2String(loadTime, 10);
    result += sim.int2String(startTime, 10);
    result += sim.int2String(responseTime, 10);
    result += sim.int2String(turnarroundTime, 10);
    result += " " + name;
    return result;
  }
}
public class Request {
  int time;
  int request;
  String filename;
  
  Request(int t, int k) {
    time = t;
    request = k;
    filename = "program" + request + ".exe";
  }
  
  public String toString() {
    return sim.int2String(time, 3) + " : " + request;
  }
}
public class Simulator extends Drawable{
  
  //Graphics related
  final int lightgreen = 0xFF28F741;
  final int green = 0xFF28AD1F;
  final int darkgreen = 0xFF075D32;
  
  final int pink = 0xFFFFC4F5;
  final int red = 0xFFF22735;
  final int maroon = 0xFFA00606;
  
  final int aqua = 0xFF62C1FA;
  final int blue = 0xFF4C55EA;
  final int darkblue = 0xFF0A05A7;
  
  final int yellow = 0xFFFAF026;
  final int orange = 0xFFFC8F00;
  
  final int white = 0xFFFFFFFF;
  final int black = 0xFF000000;
  
  final int lightgray = 0xFFCCCCCC;
  final int gray = 0xFF777777;
  final int darkgray = 0xFF333333;
  
  final int maxFrameRate = 40;
  
  private PFont courierBold;
  private PFont courier;
  
  private int CPUoutColor;
  private int CPUinColor;
  private int busColor;
  private int fetchExecute;  
  
  private CPU cpu;
  private RAM ram;
  private PartitionList partitionList;
  private OSInfo osInfo;
  private Requests requests;
  private KeyboardBuffer keyBuffer;
  private ProcessTable processTable;
  private ProcessQueue readyQueue;
  private Screen screen;
  private Clock clock;
  
  private float firstcolX, firstrowY, secondrowY;
  
  private int speed;
  private boolean isRunning;  
  private ArrayList<Request> userRequests;
  
  String explanation;
  
  //Statistics related
  ArrayList<ProcessStats> processStatistics;
  int idleTime;
  int contextSwitchTime;
  int utilisationTime;
  int timesBlocked;
  int requestTotal;
  int requestFails;
  PrintWriter output;
  
  Simulator() {
    this.initialise(0,0,width, height);
    speed = 20;
    isRunning = true;
    frameRate(maxFrameRate);
    firstcolX = 10;
    firstrowY = 10;
    secondrowY = 230;
    
    cpu = new CPU();
    cpu.initialise(firstcolX, firstrowY, 100, 0);
    
    ram = new RAM(myOS.partitionTable);
    ram.placeNextTo(cpu,30).resize(width - 20 - ram.getX(), 0);
    
    partitionList = new PartitionList(myOS.partitionTable);
    partitionList.initialise(ram.getX(), 190, ram.getW(), 0);
    
    osInfo = new OSInfo(18);
    osInfo.initialise(firstcolX, secondrowY, 150f, 0f);
    
    requests = new Requests(18);
    requests.placeNextTo(osInfo, 10).resize(110, 0);
    
    keyBuffer = new KeyboardBuffer(18);
    keyBuffer.placeNextTo(requests, 10).resize(50, 0);
    
    processTable = new ProcessTable(myOS.processTable, 18);
    processTable.placeNextTo(keyBuffer, 10).resize(380, 0);
    
    readyQueue = new ProcessQueue(myOS.readyQueue, "READY QUEUE", 18);
    readyQueue.placeNextTo(processTable, 10).resize(220, 0);
    
    clock = new Clock();
    clock.initialise(firstcolX + 75, secondrowY + 225, 150, 150);
    
    screen = new Screen();
    screen.initialise(firstcolX, 550, 300, 0);
    
    courierBold = createFont("courbd.ttf", 18);
    courier = createFont("cour.ttf", 18);
    
    userRequests = new ArrayList<Request>();
    processStatistics = new ArrayList<ProcessStats>();
    output = createWriter("Simulation.log");
    addToLog("=============== New Simulation ===============");
    addToLog("==============================================\n");
  }
  
  //PUBLIC METHODS///////////////////////////////
  ///////////////////////////////////////////////
  
  public void setupSimulation() {
    setupRequests(false);
    myPC.powerOn();
  }
  
  public void increaseSpeed() {
    speed -= 5;
    speed = constrain(speed, 1, maxFrameRate);
  }
  
  public void decreaseSpeed() {
    speed += 5;
    speed = constrain(speed, 1, maxFrameRate);
  }
  
  public void addToLog(String message) {
    println(message);  
    output.println(message);
    explanation += message + "\n";
  }
  
  public void newRequest(int req) {
    userRequests.add(new Request(myPC.clock, req)); 
  }
  
  public void step() {
    addToLog("============== SIMULATION STEP " + (myPC.clock + 1) + " ==============");
    if (!userRequests.isEmpty() && myPC.clock >= userRequests.get(0).time) {
      myPC.keyBoardEvent(userRequests.get(0).request);  
      userRequests.remove(0);
    }
    myPC.ticToc();
    render();
  }
  
  public void update() {
    explanation = "";
    if (frameCount % speed == 0  && isRunning && frameCount > 1) {
      render();
      step();
    } if (sim.isRunning) {
      clock.render();
    }
  }
  
  public void endSimulation() {
    float avLT = 0;
    float avRT = 0;
    float avTT = 0;
    addToLog("======================================");
    addToLog(" - Simulation ended on Time " + myPC.clock);
    addToLog("Statistics:");
    if (processStatistics.isEmpty()) {
      addToLog(" - No statistics");
    } else {
      addToLog(":   PID   : LoadTime : startTim : respTime : TurnTime :     Name");
      for (ProcessStats ps : processStatistics) {
        addToLog(ps.toString());
        avLT += ps.loadTime;
        avRT += ps.responseTime;
        avTT += ps.turnarroundTime;
      }
      avRT /= processStatistics.size();
      avTT /= processStatistics.size();
      avLT /= processStatistics.size();
      addToLog(" - Total requests            = " + requestTotal);
      addToLog(" - Requests served           = " + processStatistics.size());
      addToLog(" - Requests failed           = " + requestFails);
      addToLog(" - Average Load Time         = " + avLT);
      addToLog(" - Average Responce Time     = " + avRT);
      addToLog(" - Average Turnarround Time  = " + avTT);
      addToLog(" - Total simulation time     = " + myPC.clock);
      addToLog(" - Idle time (IT)            = " + idleTime);
      addToLog(" - Context switch time (CWT) = " + contextSwitchTime);
      addToLog(" - Utility time (UT)         = " + utilisationTime);
      addToLog(" - Simulation time = idle + CWT + UT +(1?) [" + myPC.clock + " = " + (idleTime + contextSwitchTime + utilisationTime) + " +(1?)]");
    }
    output.flush(); // Writes the remaining data to the file
    output.close(); // Finishes the file
    exit();  
  }
  
  public void render() {
    background(aqua);
    if (myPC.clock % 2 == 1) {
      fetchExecute = lightgreen;
      CPUoutColor = white;
      CPUinColor = fetchExecute;
      busColor = lightgreen;
    } else {
      fetchExecute = blue;
      CPUoutColor = white;
      CPUinColor = fetchExecute;
      busColor = gray;
    }
    
    cpu.render();
    ram.render();
    partitionList.render();
    
    osInfo.render();
    requests.render();
    keyBuffer.render();
    processTable.render();
    readyQueue.render();    
    
    clock.render();
    screen.render(); 
    
  }
  
  //PRIVATE METHODS//////////////////////////////
  ///////////////////////////////////////////////
  
  private void setupRequests(boolean batch) {
    //FEEL FREE TO EXPERIMENT WITH THIS LIST
    //REMEMBER new Request(time, keyPressed)
    userRequests.add(new Request(batch ? 0 : 3, 1));
    userRequests.add(new Request(batch ? 0 : 18, 2));
    userRequests.add(new Request(batch ? 0 : 28, 3));
    userRequests.add(new Request(batch ? 0 : 40, 1));
    userRequests.add(new Request(batch ? 0 : 48, 2));
    userRequests.add(new Request(batch ? 0 : 60, 3));
    userRequests.add(new Request(batch ? 0 : 68, 1));
    userRequests.add(new Request(batch ? 0 : 110, 3));
    userRequests.add(new Request(batch ? 0 : 131, 2));
    userRequests.add(new Request(batch ? 0 : 141, 2));
    userRequests.add(new Request(batch ? 0 : 162, 3));
  }
  
}

/////////////////////////////////////////////////////
public abstract class Drawable{
  protected float x, y, w, h;
  
  public void initialise(float x, float y, float w, float h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
  
  public Drawable resize(float w, float h) {
    this.w = w;
    this.h = h;
    return this;
  }
  
  public Drawable placeNextTo(Drawable other, float d) {
    this.x = other.getX() + other.getW() + d;
    this.y = other.getY();
    return this;
  }
  
  public float getX() {return x;}
  public float getY() {return y;}
  public float getW() {return w;}
  public float getH() {return h;}
  
  public String int2String(int num, int stringSize) {
    String intAsString = String.valueOf(num);
    String space = "";
    int intSize = intAsString.length();
    if (stringSize > intSize) {
      int d = stringSize - intSize;
      for (int i = 0; i < d; i++) {
        space += " ";  
      }
      intAsString = space + intAsString;
    }
    return intAsString;
  }
  
  public abstract void render();
}
//////////////////////////////////////////
public class CPU extends Drawable{
  
  public void render() {
    pushMatrix();
    translate(x, y);
    rectMode(CORNER);
    textFont(sim.courierBold);
    stroke(0);
    strokeWeight(5);
    //outer rect of top CPU
    fill(sim.CPUoutColor);
    rect(0, 0, w, w);
    strokeWeight(1);
    fill(sim.CPUinColor);
    //inner rect of top CPU
    rect(w * 0.16f, w * 0.16f, w * 0.68f, w * 0.68f, 7);
    fill(sim.black);
    pushStyle();
    textSize(50);
    textAlign(CENTER, CENTER);
    text(myPC.IR, w * 0.5f, w * 0.5f);
    popStyle();
    triangle(w * 0.05f, w * 0.85f, w * 0.05f, w * 0.95f, w * 0.15f, w * 0.95f);
    pushStyle();
    textAlign(CENTER, CENTER);
    textSize(10);
    strokeWeight(1);
    //interrupts
    if (myPC.interruptsEnabled) {
      fill(sim.green);
      rect(0, w, w, w * 0.20f);
      fill(sim.black);
      text("Int/pts Enabled", w * 0.5f, w * 1.1f);
    } else {
      fill(sim.red);
      rect(0, w, w, w * 0.20f);
      fill(sim.black);
      text("Int/pts Disabled", w * 0.5f, w * 1.1f);
    }
    for (int i = 0; i < myPC.IRQ.length / 2; i++) {
      if (i <=  myOS.kernel.size()) {
        if (myPC.IRQ[i]) {
          fill(sim.red);
          rect((i) * (w / (myPC.IRQ.length / 2)), 1.2f * w,(w / (myPC.IRQ.length / 2)), 0.2f * w);
          fill(sim.black);
        } else{
          fill(sim.green);  
          rect((i) * (w / (myPC.IRQ.length / 2)), 1.2f * w,(w / (myPC.IRQ.length / 2)), 0.2f * w);
          fill(sim.black);
        }
        text(myPC.IRQname[i],(i + 0.5f) * (w / (myPC.IRQ.length / 2)), w * 1.3f);
      } else{
        fill(sim.white);
        rect((i) * (w / (myPC.IRQ.length / 2)), 1.2f * w,(w / (myPC.IRQ.length / 2)), 0.2f * w);
      }
    }
    for (int i = 0; i < myPC.IRQ.length / 2; i++) {
      if (i + myPC.IRQ.length <=  myOS.kernel.size()) {
        if (myPC.IRQ[i + myPC.IRQ.length / 2]) {
          fill(sim.red);
          rect((i) * (w / (myPC.IRQ.length / 2)), 1.4f * w,(w / (myPC.IRQ.length / 2)), 0.2f * w);
          fill(sim.black);
        } else{
          fill(sim.green);  
          rect((i) * (w / (myPC.IRQ.length / 2)), 1.4f * w,(w / (myPC.IRQ.length / 2)), 0.2f * w);
          fill(sim.black);
        }
        text(myPC.IRQname[i + myPC.IRQ.length / 2],(i + 0.5f) * (w / (myPC.IRQ.length / 2)), w * 1.5f);
      } else{
        fill(sim.white);
        rect((i) * (w / (myPC.IRQ.length / 2)), 1.4f * w,(w / (myPC.IRQ.length / 2)), 0.2f * w);
      }
    }
    //counter register
    fill(sim.white);
    rect(0, 1.6f * w, w, w * 0.20f);
    fill(sim.black);
    text("Counter: " + myPC.counter, w * 0.5f, w * 1.7f);
    //MAR
    fill(sim.white);
    rect(0, 1.8f * w, w, w * 0.20f);
    fill(sim.black);
    text("MAR: " + myPC.MAR, w * 0.5f, w * 1.9f);
    
    popStyle();
    popMatrix();
  }
  
}
/////////////////////////////////////////
public class Clock extends Drawable{ 
  
  public void render() {
    fill(sim.fetchExecute);
    float inc = (frameCount % sim.speed) * TWO_PI / sim.speed;
    noStroke();
    arc(x, y, w, w, -HALF_PI, -HALF_PI + inc, PIE);
    pushStyle();
    textFont(sim.courierBold);
    textSize(w * 0.4f);
    fill(sim.black);
    textAlign(CENTER, CENTER);
    text(myPC.clock, x, y);
    popStyle();
  }
  
}
//////////////////////////////////////////
public class OSInfo extends Drawable{
  private float ts;
  
  OSInfo(float textSize) {
    ts = textSize;
  }
  
  public void render() {
    pushMatrix();
    translate(x, y);
    noStroke();
    rectMode(CORNER);
    textSize(ts);
    fill(sim.darkgreen);
    rect(0, 0, w, ts * 1.2f);
    rect(0, 2 * ts * 1.2f + 5, w, ts * 1.2f);
    fill(sim.white);
    rect(0, ts * 1.2f, w, ts * 1.2f);
    rect(0, 3 * ts * 1.2f + 5, w, ts * 1.2f);
    
    textAlign(CENTER, CENTER);
    textFont(sim.courierBold);
    fill(sim.white);
    text("Running", w / 2, ts / 2);    
    text("Sus/ded", w / 2, 2 * ts * 1.2f + ts / 2 + 5);
    
    fill(sim.black);
    textFont(sim.courier);
    text(myOS.active ==  null ? "NULL" : myOS.active.reference, w / 2, ts * 1.2f + ts / 2);
    String sus = myOS.suspended ==  null ? "NULL" : myOS.suspended.reference;
    text(sus, w / 2, 3 * ts * 1.2f + ts / 2 + 5);
    popMatrix();
  }
}
//////////////////////////////////////////
public class RAM extends Drawable{
  
  ArrayList<Partition> partitionTable;
  float sqSize;
  
  RAM(ArrayList<Partition> partitionTable) {
    this.partitionTable = partitionTable;
  }
  
  public void render() {
    sqSize = w / myPC.maxRAMSizeInBank;
    pushMatrix();
    translate(x, y);
    textFont(sim.courier);
    
    for (int i = 0; i < myPC.RAMBanks; i++) {
      drawRAMBank(i, false);
    }
    for (int i = myPC.RAMBanks; i < myPC.maxRAMBanks; i++) {
      drawRAMBank(i, true);
    }
    popMatrix();
  }
  
  private void drawRAMBank(int bank, boolean empty) {
    int squares = myPC.RAMSizeInBank;
    stroke(0);
    pushMatrix();
    translate(0, 45 * bank);
    textAlign(CENTER, CENTER);
    int partitionIndex;
    if (!empty) {
      //draw the BUS lines
      for (int i = 0; i < myPC.maxRAMSizeInBank; i++) {
        drawBus(i, sqSize, sim.darkgray);
      }
      for (int i = 0; i < myPC.maxRAMSizeInBank; i++) {
        if (i < squares) {
          //Draw the partitions
          partitionIndex = findPI(bank * myPC.RAMSizeInBank + i);
          //println("Bank = "+bank+" Address = "+(bank*myPC.RAMSizeInBank+i)+" PI = "+partitionIndex);
          if (partitionIndex % 2 ==  1) {
            fill(sim.white);
          } else {
            fill(sim.black);
          }
          noStroke();
          if (partitionIndex >-  1) {
            rect(i * sqSize, -0.15f * sqSize, sqSize, sqSize * 1.3f);
          }
          if (partitionIndex >-  1) {
            if ((bank * myPC.RAMSizeInBank + i) == partitionTable.get(partitionIndex).baseAddress) {
              pushStyle();
              textSize(8);
              fill(sim.black);
              textAlign(CENTER, BOTTOM);
              text(bank * myPC.RAMSizeInBank + i, i * sqSize, -0.15f * sqSize);
              popStyle();
            }
          }
          
          //draw the ram
          if (myPC.MAR == i + bank * myPC.RAMSizeInBank) {
            fill(sim.fetchExecute);
            drawBus(i, sqSize, sim.busColor);
          } else if (myPC.RAM[bank][i] == ' ') {
            fill(sim.white);
          } else if (bank == 0 && i < partitionTable.get(0).size) {
            fill(sim.lightgray);
          } else{
            fill(sim.pink);
          }
          stroke(sim.black);
          
          square(i * sqSize, 0, sqSize);
          fill(0);
          text(myPC.RAM[bank][i], i * sqSize + sqSize / 2, sqSize / 2);
        } else{
          fill(sim.gray);
          stroke(sim.black);
          rect(i * sqSize, -0.15f * sqSize, sqSize, sqSize * 1.3f);
        }
      }
    } else {
      for (int i = 0; i < myPC.maxRAMSizeInBank; i++) {
        fill(sim.gray);
        stroke(sim.black);
        rect(i * sqSize, -0.15f * sqSize, sqSize, sqSize * 1.3f);
        drawBus(i, sqSize, sim.gray);
      }
    }
    popMatrix();
  }
  
  private int findPI(int address) {
    int result = -1;
    for (Partition p : partitionTable) {
      if (address >=  p.baseAddress && address < p.baseAddress + p.size) {
        result =  partitionTable.indexOf(p);
        break;
      }
    }
    return result;
  }
  
  private void drawBus(int i, float sqSize, int c) {
    stroke(c);
    strokeWeight(2);
    strokeCap(ROUND);
    line(i * sqSize + 0.5f * sqSize, sqSize, i * sqSize + 0.5f * sqSize, 1.5f * sqSize);
    line(i * sqSize + 0.5f * sqSize, 1.5f * sqSize, -2 * sqSize, 1.5f * sqSize);
    strokeWeight(1);
    stroke(sim.black);
  }  
  
}
//////////////////////////////////
public class Requests extends Drawable{
  private int ts;
  
  Requests(int ts) {
    this.ts = ts;
  }
  
  public void render() {
    pushMatrix();
    translate(x, y);
    
    noStroke();
    rectMode(CORNER);
    textSize(ts);
    textFont(sim.courierBold);
    
    fill(sim.darkgreen);
    rect(0, 0, w, ts * 1.2f);
    textAlign(CENTER, CENTER);
    fill(sim.white);
    text("USER REQs", w / 2, ts / 2 - 2);
    
    
    fill(sim.green);
    rect(0, ts * 1.2f, w, ts * 1.2f);
    textAlign(LEFT, CENTER);
    fill(sim.white);
    text("  t : Key", 0, ts * 1.2f + ts / 2 - 2);
    
    textFont(sim.courier);
    int count = 0;
    for (int i = 0; i < sim.userRequests.size(); i++) {
      if (sim.userRequests.get(i).time <= myPC.clock) {
        if (i == 0) {
          fill(sim.red);
        } else {
          fill(sim.pink);
        }
      } else {
        fill(sim.white);
      }
      rect(0,(count + 2) * ts * 1.2f, w, ts * 1.2f + 2);
      fill(sim.black);
      text(sim.userRequests.get(i).toString(), 0,(count + 2) * ts * 1.2f + ts / 2 - 2);
      count++;
    }
    popMatrix();
  }
  
}
///////////////////////////////////////
public class KeyboardBuffer extends Drawable{
  int ts;
  
  KeyboardBuffer(int ts) {
    this.ts = ts;  
  }
  
  public void render() {
    pushMatrix();
    translate(x, y);
    
    noStroke();
    rectMode(CORNER);
    textSize(ts);
    textFont(sim.courierBold);
    
    fill(sim.darkgreen);
    rect(0, 0, w, ts * 1.2f);
    textAlign(CENTER, CENTER);
    fill(sim.white);
    text("BUFF", w / 2, ts / 2 - 2);
    
    
    fill(sim.green);
    rect(0, ts * 1.2f, w, ts * 1.2f);
    textAlign(CENTER, CENTER);
    fill(sim.white);
    text("Key", w / 2, ts * 1.2f + ts / 2 - 2);
    
    textFont(sim.courier);
    
    for (int i = 0; i < myPC.keyboardBuffer.size(); i++) {
      fill(sim.white);
      rect(0,(i + 2) * ts * 1.2f, w, ts * 1.2f + 2);
      fill(sim.black);
      text(myPC.keyboardBuffer.get(i), w / 2,(i + 2) * ts * 1.2f + ts / 2 - 2);
    }
    popMatrix();          
  }
  
}
////////////////////////////////
public class PartitionList extends Drawable{
  
  ArrayList<Partition> partitionTable;
  
  PartitionList(ArrayList<Partition> partitionTable) {
    this.partitionTable = partitionTable;  
  }
  
  public void render() {
    float sqSize;
    float start = 0;
    pushMatrix();
    pushStyle();
    translate(x, y);
    for (int i = 0; i < partitionTable.size(); i++) {
      sqSize = w * partitionTable.get(i).size / myPC.RAMSize;
      if (partitionTable.get(i).isFree) {
        fill(sim.white);  
      } else{
        fill(sim.lightgray);  
      }
      rect(start, 0, sqSize, 20);
      fill(sim.black);
      textAlign(CENTER, CENTER);
      textSize(18);
      text(partitionTable.get(i).size, start + sqSize / 2, 10);
      textSize(12);
      textAlign(CENTER, BOTTOM);
      text(partitionTable.get(i).baseAddress, start, 0);
      start += sqSize;
    }
    popStyle();
    popMatrix();
  }
}
///////////////////////////////
public class ProcessTable extends Drawable{
  int ts;
  ArrayList<PCB> processTable;
  
  
  ProcessTable(ArrayList<PCB> table, int ts) {
    this.ts = ts;  
    this.processTable = table;
  }
  
  public void render() {
    pushMatrix();
    translate(x, y);
    
    noStroke();
    rectMode(CORNER);
    textSize(ts);
    textFont(sim.courierBold);
    
    fill(sim.darkgreen);
    rect(0, 0, w, ts * 1.2f);
    textAlign(CENTER, CENTER);
    fill(sim.white);
    text("PROCESS TABLE", w / 2, ts / 2 - 2);
    
    fill(sim.green);
    rect(0, ts * 1.2f, w, ts * 1.2f);
    textAlign(LEFT, CENTER);
    fill(sim.white);
    text(" PID : PC : STATE   : Name", 0, ts * 1.2f + ts / 2 - 2);
    
    textFont(sim.courier);
    int count = 0;
    for (PCB p : processTable) {
      if (p instanceof KernelProcess) fill(sim.lightgray);
      else fill(sim.white);
      rect(0,(count + 2) * ts * 1.2f, w, ts * 1.2f + 2);
      if (p.state ==  STATE.NEW) fill(sim.orange);
      else if (p.state ==  STATE.READY) fill(sim.darkgreen);
      else if (p.state ==  STATE.BLOCKED) fill(sim.red);
      else if (p.state ==  STATE.RUNNING) fill(sim.blue);
      else fill(sim.maroon);
      text(p.toString(), 0,(count + 2) * ts * 1.2f + ts / 2 - 2);
      count++;
    }
    popMatrix();
  }
  
}
////////////////////////////////////////
public class ProcessQueue extends Drawable{
  ArrayList<UserProcess> queue;
  String title;
  int ts;
  
  ProcessQueue(ArrayList<UserProcess> queue, String title, int ts) {
    this.queue = queue;
    this.title = title;
    this.ts = ts;
  }
  
  public void render() {
    pushMatrix();
    translate(x, y); 
    
    noStroke();
    rectMode(CORNER);
    textSize(ts);
    textFont(sim.courierBold);
    
    fill(sim.darkgreen);
    rect(0, 0, w, ts * 1.2f);
    textAlign(CENTER, CENTER);
    fill(sim.white);
    text(title, w / 2, ts / 2 - 2);
    
    fill(sim.green);
    rect(0, ts * 1.2f, w, ts * 1.2f);
    textAlign(LEFT, CENTER);
    fill(sim.white);
    text("PID : LT : PR : SZ", 5, ts * 1.2f + ts / 2 - 2);
    
    int count = 0;
    textFont(sim.courier);
    for (UserProcess p : queue) {
      fill(sim.white);
      rect(0,(count + 2) * ts * 1.2f, w, ts * 1.2f + 2);
      fill(sim.black);
      text(int2String(p.pid, 3) + " :" + int2String(p.loadTime, 3) + " :" + int2String(p.priority,2) + "  : " + int2String(p.codeSize,2), 5,(count + 2) * ts * 1.2f + ts / 2 - 2);
      count++;
    }
    popMatrix();
  }
}
///////////////////////////////
public class Screen extends Drawable{
  
  public void render() {
    textFont(sim.courierBold);
    fill(sim.black);
    textAlign(LEFT, TOP);
    text(sim.explanation, x, y);
  }
  
}
public class UserProcess extends PCB{
  int loadTime;
  //last time it was blocked
  int blockTime;
  //time the process run its first instruction
  int startTime;
  //time the process run its last instruction
  int finishTime;
  //priority
  int priority;
  //size
  int codeSize;
  
  //CREATE
  UserProcess(int ba, String fn) {
    super(ba, fn);
    loadTime = -1;
    blockTime = -1;
    startTime = -1;
    priority = PApplet.parseInt(random(6));
    codeSize = 0;
    for (int i = 0; i < myPC.HDD.get(fn).length(); i++) {
      if (myPC.HDD.get(fn).charAt(i) == '*') {
        codeSize++;
      } else break;
    }
  }
  
  //ADMIT [NEW -> READY]
  public void admit() {
    this.state = STATE.READY;  
  }
  
  //START / RESUME execution [READY -> RUN]
  public void start() {
    myOS.kernelMode = false;
    this.state = STATE.RUNNING;
    myPC.counter = this.programCounter;
    myPC.BA = this.baseAddress;
    if (startTime == -1) startTime = myPC.clock;
    myPC.interruptsEnabled = ((SchedulerKernel) myOS.kernel.get("scheduler")).isPreEmptive();
  }
  
  //PAUSE execution [RUN -> READY]
  public void pause() {
    this.state = STATE.READY;
    this.programCounter = myPC.counter;
  }
  
  //BLOCK [RUN -> BLOCK]
  public void block() {
    this.state = STATE.BLOCKED;
    this.programCounter = myPC.counter;
    this.blockTime = myPC.clock;
  }
  
  //COMPLETE [RUN -> TERMINATED]
  public void finish() {
    this.state = STATE.EXITING; 
    this.finishTime = myPC.clock;
    myPC.interruptsEnabled = true;
  }
  
}


  public void settings() { size(1400, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "OSCW2024" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
